### JAVA 锁

* #### 乐观锁
乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为 别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。   
java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入 值是否一样，一样则更新，否则失败。 

* #### 悲观锁
悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 
java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到， 才会转换为悲观锁，如RetreenLock。 
* #### 自旋锁
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁 的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）， 等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗


* #### Synchronized 同步锁 
synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重 入锁。   
_Synchronized 作用范围_
1. 作用于方法时，锁住的是对象的实例(this)； 
2. 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁， 会锁所有调用该方法的线程； 
3. synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 

_Synchronized 核心组件_  
1.  Wait Set：哪些调用wait方法被阻塞的线程被放置在这里； 
2.  Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中
3.  Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中； 
4.  OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； 
5.  Owner：当前已经获取到所资源的线程被称为Owner；
6   !Owner：当前释放锁的线程

* #### ReentrantLock 
ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完 成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等 避免多线程死锁的方法  


* #### ReadWriteLock 读写锁  
为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。   
_ReadWriteLock的实现原理_
1. 公平选择性：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先与公平
2. 可重入：读线程获取锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁
3. 可降级：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作
4. ReentrantReadWriteLock的核心是由一个基于AQS的同步器Sync构成，然后由其扩展出ReadLock（共享锁），WriteLock（排它锁）所组成


* 与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，总结起来为：读读不互斥，读写互斥，写写互斥，而一般的独占锁是：读读互斥，读写互斥，写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。
* 从ReentrantReadWriteLock的构造函数中可以发现ReadLock与WriteLock使用的是同一个Sync
